<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional QAM Communication System Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        h1 {
            font-size: 2em;
            font-weight: 300;
            color: #fff;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            font-size: 0.9em;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #111;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #1a1a1a;
            border-radius: 6px;
            border: 1px solid #333;
        }

        .control-group label {
            font-size: 0.85em;
            color: #aaa;
            white-space: nowrap;
        }

        button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }

        button:hover {
            background: #3a3a3a;
            border-color: #666;
        }

        button.active {
            background: #0066cc;
            border-color: #0088ff;
        }

        select {
            padding: 6px 12px;
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 380px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #111;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #222;
        }

        .transmitter, .receiver {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .channel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .section-title {
            font-size: 1.1em;
            color: #fff;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .data-display {
            background: #0a0a0a;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #222;
        }

        .data-display h3 {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
            font-weight: normal;
        }

        .bit-stream {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            color: #0f0;
            letter-spacing: 1px;
        }

        .error-bit {
            color: #f44;
            background: rgba(255, 68, 68, 0.2);
            padding: 0 2px;
        }

        .plot-container {
            background: #000;
            border-radius: 6px;
            border: 1px solid #222;
            position: relative;
            overflow: hidden;
        }

        .constellation {
            width: 220px;
            height: 220px;
            margin: 0 auto;
        }

        .waveform {
            height: 120px;
        }

        .spectrum {
            height: 150px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .channel-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .slider-group {
            background: #0a0a0a;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #222;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .slider-label span {
            font-size: 0.85em;
        }

        .slider-value {
            font-family: monospace;
            color: #0088ff;
            font-size: 0.9em;
            min-width: 70px;
            text-align: right;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #222;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #0088ff;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #00aaff;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #0088ff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .lock-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .lock-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #0a0a0a;
            border-radius: 4px;
            border: 1px solid #222;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .lock-indicator {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .locked .lock-indicator {
            background: #00cc44;
            color: #000;
        }

        .unlocked .lock-indicator {
            background: #cc4444;
            color: #fff;
        }

        .acquiring .lock-indicator {
            background: #ccaa00;
            color: #000;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .metric-item {
            background: #0a0a0a;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #222;
            text-align: center;
        }

        .metric-label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 1.1em;
            font-family: monospace;
            color: #0088ff;
            font-weight: 500;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.error {
            color: #ff4444;
        }

        .analysis-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .analysis-panel {
            background: #111;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #222;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            color: #fff;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #333;
            display: none;
        }

        .status-led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .status-led.green {
            background: #0f0;
            box-shadow: 0 0 4px #0f0;
        }

        .status-led.yellow {
            background: #ff0;
            box-shadow: 0 0 4px #ff0;
        }

        .status-led.red {
            background: #f00;
            box-shadow: 0 0 4px #f00;
        }

        .equalizer-taps {
            display: flex;
            align-items: flex-end;
            height: 60px;
            gap: 2px;
            margin-top: 10px;
            padding: 10px;
            background: #000;
            border-radius: 4px;
        }

        .tap {
            flex: 1;
            background: #0088ff;
            min-height: 4px;
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Professional QAM Communication System Simulator</h1>
            <div class="subtitle">Real-time DSP-based modulation and demodulation with accurate channel modeling</div>
        </header>

        <div class="controls">
            <button id="transmitBtn" onclick="toggleTransmission()">
                <span class="status-led red" id="txLed"></span>
                Start System
            </button>
            
            <div class="control-group">
                <label>Mode:</label>
                <select id="modOrder" onchange="changeModulation()">
                    <option value="4">QPSK</option>
                    <option value="16" selected>16-QAM</option>
                    <option value="64">64-QAM</option>
                    <option value="256">256-QAM</option>
                </select>
            </div>

            <div class="control-group">
                <label>Symbol Rate:</label>
                <select id="symbolRate" onchange="updateSymbolRate()">
                    <option value="1">1 MSps</option>
                    <option value="2" selected>2 MSps</option>
                    <option value="5">5 MSps</option>
                    <option value="10">10 MSps</option>
                </select>
            </div>

            <div class="control-group">
                <label>Pulse Shape:</label>
                <select id="pulseShape" onchange="updatePulseShape()">
                    <option value="rect">Rectangular</option>
                    <option value="rrc" selected>Root Raised Cosine</option>
                    <option value="gaussian">Gaussian</option>
                </select>
            </div>

            <div class="control-group">
                <label>Roll-off:</label>
                <select id="rolloff" onchange="updateRolloff()">
                    <option value="0.1">0.1</option>
                    <option value="0.25" selected>0.25</option>
                    <option value="0.35">0.35</option>
                    <option value="0.5">0.5</option>
                </select>
            </div>

            <button onclick="resetSystem()">Reset System</button>
            <button onclick="saveMetrics()">Save Metrics</button>
        </div>

        <div class="main-layout">
            <!-- Transmitter Section -->
            <div class="panel transmitter">
                <h2 class="section-title">
                    <span class="status-led" id="txStatusLed"></span>
                    Transmitter
                </h2>
                
                <div class="data-display">
                    <h3>Input Bit Stream (PN Sequence)</h3>
                    <div class="bit-stream" id="inputData">Initializing...</div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Rate: <span id="dataRate">0</span> Mbps
                    </div>
                </div>

                <div class="data-display">
                    <h3>Symbol Mapping</h3>
                    <div id="symbolMapping" style="font-family: monospace; color: #0088ff;">
                        Gray-coded mapping active
                    </div>
                </div>

                <div class="plot-container constellation">
                    <canvas id="txConstellation"></canvas>
                    <div style="text-align: center; margin-top: 5px; font-size: 0.8em; color: #888;">
                        TX Constellation (Ideal)
                    </div>
                </div>

                <div class="data-display">
                    <h3>Pulse Shaping Filter</h3>
                    <div class="plot-container waveform">
                        <canvas id="pulseShapeCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        <span id="filterInfo">SRRC, α=0.25, 8 symbols</span>
                    </div>
                </div>

                <div class="data-display">
                    <h3>Baseband I/Q Signals</h3>
                    <div class="plot-container waveform">
                        <canvas id="basebandCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Peak-to-Average: <span id="papr">0.0</span> dB
                    </div>
                </div>

                <div class="data-display">
                    <h3>RF Spectrum</h3>
                    <div class="plot-container spectrum">
                        <canvas id="txSpectrumCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        ACPR: <span id="acpr">-45.2</span> dBc
                    </div>
                </div>
            </div>

            <!-- Channel Section -->
            <div class="panel channel">
                <h2 class="section-title">
                    <span class="status-led yellow" id="channelStatusLed"></span>
                    Wireless Channel Model
                </h2>
                
                <div class="channel-controls">
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Eb/N0</span>
                            <span class="slider-value" id="ebnoValue">15.0 dB</span>
                        </div>
                        <input type="range" id="ebnoSlider" min="0" max="30" value="15" step="0.5" 
                               oninput="updateEbNo(this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Multipath Delay Spread</span>
                            <span class="slider-value" id="delaySpreadValue">0.5 μs</span>
                        </div>
                        <input type="range" id="delaySpreadSlider" min="0" max="5" value="0.5" step="0.1" 
                               oninput="updateDelaySpread(this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Doppler Frequency</span>
                            <span class="slider-value" id="dopplerValue">10 Hz</span>
                        </div>
                        <input type="range" id="dopplerSlider" min="0" max="500" value="10" step="5" 
                               oninput="updateDoppler(this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Carrier Frequency Offset</span>
                            <span class="slider-value" id="cfoValue">100 Hz</span>
                        </div>
                        <input type="range" id="cfoSlider" min="-1000" max="1000" value="100" step="10" 
                               oninput="updateCFO(this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Phase Noise (@ 1kHz)</span>
                            <span class="slider-value" id="phaseNoiseValue">-80 dBc/Hz</span>
                        </div>
                        <input type="range" id="phaseNoiseSlider" min="-100" max="-40" value="-80" step="1" 
                               oninput="updatePhaseNoise(this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>I/Q Imbalance</span>
                            <span class="slider-value" id="iqImbalanceValue">0.5 dB, 2°</span>
                        </div>
                        <input type="range" id="iqImbalanceSlider" min="0" max="5" value="0.5" step="0.1" 
                               oninput="updateIQImbalance(this.value)">
                    </div>
                </div>

                <div class="data-display">
                    <h3>Channel Impulse Response</h3>
                    <div class="plot-container waveform">
                        <canvas id="channelImpulseCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Model: <span id="channelModel">Rayleigh, TU6</span>
                    </div>
                </div>

                <div class="data-display">
                    <h3>Channel Transfer Function</h3>
                    <div class="plot-container spectrum">
                        <canvas id="channelTransferCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Coherence BW: <span id="coherenceBW">2.1</span> MHz
                    </div>
                </div>
            </div>

            <!-- Receiver Section -->
            <div class="panel receiver">
                <h2 class="section-title">
                    <span class="status-led" id="rxStatusLed"></span>
                    Receiver
                </h2>
                
                <div class="lock-status">
                    <div class="lock-item" id="agcLock">
                        <span>AGC</span>
                        <span class="lock-indicator">Converging</span>
                    </div>
                    <div class="lock-item" id="timingLock">
                        <span>Symbol Timing</span>
                        <span class="lock-indicator">Searching</span>
                    </div>
                    <div class="lock-item" id="carrierLock">
                        <span>Carrier Recovery</span>
                        <span class="lock-indicator">Searching</span>
                    </div>
                    <div class="lock-item" id="frameLock">
                        <span>Frame Sync</span>
                        <span class="lock-indicator">Searching</span>
                    </div>
                </div>

                <div class="data-display">
                    <h3>Received Signal Spectrum</h3>
                    <div class="plot-container spectrum">
                        <canvas id="rxSpectrumCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Signal Power: <span id="rxPower">-85.3</span> dBm
                    </div>
                </div>

                <div class="data-display">
                    <h3>Matched Filter Output</h3>
                    <div class="plot-container waveform">
                        <canvas id="matchedFilterCanvas"></canvas>
                    </div>
                </div>

                <div class="data-display">
                    <h3>Timing Recovery (Gardner TED)</h3>
                    <div class="plot-container waveform">
                        <canvas id="timingRecoveryCanvas"></canvas>
                    </div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Timing Error: <span id="timingError">0.00</span> samples
                    </div>
                </div>

                <div class="data-display">
                    <h3>Adaptive Equalizer (LMS)</h3>
                    <div class="equalizer-taps" id="equalizerTaps"></div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Taps: <span id="eqTaps">21</span>, μ: <span id="eqMu">0.01</span>
                    </div>
                </div>

                <div class="plot-container constellation">
                    <canvas id="rxConstellation"></canvas>
                    <div style="text-align: center; margin-top: 5px; font-size: 0.8em; color: #888;">
                        RX Constellation (After Equalization)
                    </div>
                </div>

                <div class="data-display">
                    <h3>Output Bit Stream</h3>
                    <div class="bit-stream" id="outputData">Synchronizing...</div>
                    <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                        Latency: <span id="latency">0</span> ms
                    </div>
                </div>

                <div class="metrics-grid">
                    <div class="metric-item">
                        <div class="metric-label">BER</div>
                        <div class="metric-value" id="berValue">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">EVM</div>
                        <div class="metric-value" id="evmValue">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">MER</div>
                        <div class="metric-value" id="merValue">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">SNR</div>
                        <div class="metric-value" id="snrValue">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">CFO Est.</div>
                        <div class="metric-value" id="cfoEstValue">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Throughput</div>
                        <div class="metric-value" id="throughputValue">--</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analysis Section -->
        <div class="analysis-section">
            <div class="analysis-panel">
                <h3 class="section-title">Eye Diagram Analysis</h3>
                <div class="plot-container" style="height: 200px;">
                    <canvas id="eyeDiagram"></canvas>
                </div>
                <div class="metrics-grid" style="margin-top: 10px;">
                    <div class="metric-item">
                        <div class="metric-label">Eye Height</div>
                        <div class="metric-value" id="eyeHeight">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Eye Width</div>
                        <div class="metric-value" id="eyeWidth">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Q Factor</div>
                        <div class="metric-value" id="qFactor">--</div>
                    </div>
                </div>
            </div>

            <div class="analysis-panel">
                <h3 class="section-title">BER Performance</h3>
                <div class="plot-container" style="height: 200px;">
                    <canvas id="berCurve"></canvas>
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #888;">
                    <div>Theory: AWGN channel</div>
                    <div>Measured: Real-time with impairments</div>
                </div>
            </div>

            <div class="analysis-panel">
                <h3 class="section-title">Constellation Density</h3>
                <div class="plot-container" style="height: 200px;">
                    <canvas id="constellationDensity"></canvas>
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #888;">
                    <div>2D histogram of received symbols</div>
                    <div>Shows clustering and spread</div>
                </div>
            </div>

            <div class="analysis-panel">
                <h3 class="section-title">Loop Convergence</h3>
                <div class="plot-container" style="height: 200px;">
                    <canvas id="loopConvergence"></canvas>
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #888;">
                    <div>Carrier phase: <span id="carrierPhaseConv">Converging</span></div>
                    <div>Symbol timing: <span id="symbolTimingConv">Converging</span></div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Advanced DSP Implementation
        class QAMSystem {
            constructor() {
                this.sampleRate = 20e6; // 20 MHz
                this.symbolRate = 2e6;  // 2 MSps
                this.samplesPerSymbol = this.sampleRate / this.symbolRate;
                this.modOrder = 16;
                this.rolloff = 0.25;
                this.filterSpan = 8;
                this.isRunning = false;
                
                // Buffers
                this.txBuffer = [];
                this.rxBuffer = [];
                this.symbolBuffer = [];
                
                // DSP Components
                this.pulseShapeFilter = null;
                this.matchedFilter = null;
                this.equalizer = null;
                this.timingRecovery = null;
                this.carrierRecovery = null;
                
                // Channel parameters
                this.channel = {
                    ebNo: 15,
                    delaySpread: 0.5e-6,
                    dopplerFreq: 10,
                    cfo: 100,
                    phaseNoise: -80,
                    iqImbalance: { gain: 0.5, phase: 2 }
                };
                
                // Metrics
                this.metrics = {
                    ber: 0,
                    evm: 0,
                    mer: 0,
                    snr: 0,
                    eyeHeight: 0,
                    eyeWidth: 0
                };
                
                this.initializeDSP();
                this.initializeCanvases();
            }
            
            initializeDSP() {
                // Create SRRC filter
                this.createPulseShapeFilter();
                
                // Initialize synchronization loops
                this.initializeTimingRecovery();
                this.initializeCarrierRecovery();
                
                // Initialize adaptive equalizer
                this.initializeEqualizer();
            }
            
            createPulseShapeFilter() {
                const numTaps = this.filterSpan * this.samplesPerSymbol + 1;
                this.pulseShapeFilter = new Float32Array(numTaps);
                this.matchedFilter = new Float32Array(numTaps);
                
                const t_step = 1 / this.sampleRate;
                const alpha = this.rolloff;
                
                for (let i = 0; i < numTaps; i++) {
                    const t = (i - numTaps/2) * t_step;
                    const t_norm = t * this.symbolRate;
                    
                    if (t_norm === 0) {
                        this.pulseShapeFilter[i] = 1 - alpha + 4 * alpha / Math.PI;
                    } else if (Math.abs(t_norm) === 1/(4*alpha)) {
                        this.pulseShapeFilter[i] = (alpha/Math.sqrt(2)) * ((1+2/Math.PI)*Math.sin(Math.PI/(4*alpha)) + (1-2/Math.PI)*Math.cos(Math.PI/(4*alpha)));
                    } else {
                        const num = Math.sin(Math.PI*t_norm*(1-alpha)) + 4*alpha*t_norm*Math.cos(Math.PI*t_norm*(1+alpha));
                        const den = Math.PI*t_norm*(1-Math.pow(4*alpha*t_norm, 2));
                        this.pulseShapeFilter[i] = num / den;
                    }
                }
                
                // Normalize filter
                let sum = 0;
                for (let i = 0; i < numTaps; i++) {
                    sum += this.pulseShapeFilter[i] * this.pulseShapeFilter[i];
                }
                const scale = Math.sqrt(this.samplesPerSymbol / sum);
                
                for (let i = 0; i < numTaps; i++) {
                    this.pulseShapeFilter[i] *= scale;
                    this.matchedFilter[i] = this.pulseShapeFilter[numTaps - 1 - i];
                }
            }
            
            initializeTimingRecovery() {
                this.timingRecovery = {
                    mu: 0,
                    gain: 0.01,
                    tedGain: 1,
                    buffer: new Array(4).fill({re: 0, im: 0}),
                    error: 0,
                    locked: false
                };
            }
            
            initializeCarrierRecovery() {
                this.carrierRecovery = {
                    phase: 0,
                    frequency: 0,
                    loopBW: 0.01,
                    damping: 0.707,
                    error: 0,
                    locked: false,
                    integrator: 0
                };
            }
            
            initializeEqualizer() {
                const numTaps = 21;
                this.equalizer = {
                    taps: new Array(numTaps).fill(0).map(() => ({re: 0, im: 0})),
                    mu: 0.01,
                    buffer: new Array(numTaps).fill({re: 0, im: 0})
                };
                // Initialize with center tap
                this.equalizer.taps[Math.floor(numTaps/2)] = {re: 1, im: 0};
            }
            
            // Modulation functions
            generateSymbols(numSymbols) {
                const symbols = [];
                const bitsPerSymbol = Math.log2(this.modOrder);
                
                for (let i = 0; i < numSymbols; i++) {
                    // Generate random bits
                    let bits = 0;
                    for (let b = 0; b < bitsPerSymbol; b++) {
                        bits = (bits << 1) | (Math.random() > 0.5 ? 1 : 0);
                    }
                    
                    // Gray coding and constellation mapping
                    const symbol = this.mapToConstellation(bits);
                    symbols.push(symbol);
                }
                
                return symbols;
            }
            
            mapToConstellation(bits) {
                const k = Math.sqrt(this.modOrder);
                const bitsPerAxis = Math.log2(k);
                
                // Gray decoding
                let gray = bits;
                for (let i = 1; i < Math.log2(this.modOrder); i++) {
                    gray ^= bits >> i;
                }
                
                // Map to constellation point
                const i = gray & ((1 << bitsPerAxis) - 1);
                const q = gray >> bitsPerAxis;
                
                // Normalize constellation
                const scale = Math.sqrt(2 / (this.modOrder - 1));
                const I = scale * (2 * i - k + 1);
                const Q = scale * (2 * q - k + 1);
                
                return { re: I, im: Q, bits: bits };
            }
            
            // Pulse shaping
            pulseShape(symbols) {
                const upsampled = new Array(symbols.length * this.samplesPerSymbol).fill({re: 0, im: 0});
                
                // Upsample
                for (let i = 0; i < symbols.length; i++) {
                    upsampled[i * this.samplesPerSymbol] = symbols[i];
                }
                
                // Filter
                return this.filterComplex(upsampled, this.pulseShapeFilter);
            }
            
            // Channel simulation
            applyChannel(signal) {
                let output = [...signal];
                
                // Add multipath
                output = this.applyMultipath(output);
                
                // Add carrier frequency offset
                output = this.applyCFO(output);
                
                // Add phase noise
                output = this.applyPhaseNoise(output);
                
                // Add AWGN
                output = this.addAWGN(output);
                
                // Apply I/Q imbalance
                output = this.applyIQImbalance(output);
                
                return output;
            }
            
            applyMultipath(signal) {
                // Simple 3-tap channel model
                const taps = [
                    { delay: 0, gain: 1, phase: 0 },
                    { delay: Math.floor(this.channel.delaySpread * this.sampleRate), gain: 0.5, phase: Math.PI/4 },
                    { delay: Math.floor(2 * this.channel.delaySpread * this.sampleRate), gain: 0.3, phase: Math.PI/2 }
                ];
                
                const output = new Array(signal.length).fill({re: 0, im: 0});
                
                for (const tap of taps) {
                    for (let i = tap.delay; i < signal.length; i++) {
                        const rotated = this.complexMultiply(
                            signal[i - tap.delay],
                            { re: tap.gain * Math.cos(tap.phase), im: tap.gain * Math.sin(tap.phase) }
                        );
                        output[i] = this.complexAdd(output[i], rotated);
                    }
                }
                
                return output;
            }
            
            applyCFO(signal) {
                const cfoRad = 2 * Math.PI * this.channel.cfo / this.sampleRate;
                return signal.map((sample, i) => {
                    const rotation = { re: Math.cos(cfoRad * i), im: Math.sin(cfoRad * i) };
                    return this.complexMultiply(sample, rotation);
                });
            }
            
            applyPhaseNoise(signal) {
                let phase = 0;
                const variance = Math.pow(10, this.channel.phaseNoise / 10) * 2 * Math.PI / this.sampleRate;
                
                return signal.map(sample => {
                    phase += Math.sqrt(variance) * this.gaussianRandom();
                    const rotation = { re: Math.cos(phase), im: Math.sin(phase) };
                    return this.complexMultiply(sample, rotation);
                });
            }
            
            addAWGN(signal) {
                const snr = this.channel.ebNo + 10 * Math.log10(Math.log2(this.modOrder));
                const noiseVar = 1 / Math.pow(10, snr / 10);
                const noiseSigma = Math.sqrt(noiseVar / 2);
                
                return signal.map(sample => ({
                    re: sample.re + noiseSigma * this.gaussianRandom(),
                    im: sample.im + noiseSigma * this.gaussianRandom()
                }));
            }
            
            applyIQImbalance(signal) {
                const gainImb = 1 + this.channel.iqImbalance.gain / 100;
                const phaseImb = this.channel.iqImbalance.phase * Math.PI / 180;
                
                return signal.map(sample => ({
                    re: sample.re,
                    im: gainImb * (sample.im * Math.cos(phaseImb) + sample.re * Math.sin(phaseImb))
                }));
            }
            
            // Receiver processing
            receiverProcess(signal) {
                // Matched filter
                let filtered = this.filterComplex(signal, this.matchedFilter);
                
                // AGC
                filtered = this.applyAGC(filtered);
                
                // Timing recovery
                const symbols = this.timingRecoveryProcess(filtered);
                
                // Carrier recovery
                const corrected = this.carrierRecoveryProcess(symbols);
                
                // Equalization
                const equalized = this.equalizerProcess(corrected);
                
                return equalized;
            }
            
            applyAGC(signal) {
                const targetPower = 1;
                let power = 0;
                
                // Estimate power
                for (let i = 0; i < Math.min(1000, signal.length); i++) {
                    power += signal[i].re * signal[i].re + signal[i].im * signal[i].im;
                }
                power /= Math.min(1000, signal.length);
                
                const gain = Math.sqrt(targetPower / power);
                return signal.map(s => ({ re: s.re * gain, im: s.im * gain }));
            }
            
            timingRecoveryProcess(signal) {
                const symbols = [];
                let i = 0;
                
                while (i < signal.length - this.samplesPerSymbol) {
                    // Interpolate at current mu
                    const index = Math.floor(i + this.timingRecovery.mu * this.samplesPerSymbol);
                    const frac = (i + this.timingRecovery.mu * this.samplesPerSymbol) - index;
                    
                    if (index + 1 < signal.length) {
                        const interpolated = {
                            re: signal[index].re * (1 - frac) + signal[index + 1].re * frac,
                            im: signal[index].im * (1 - frac) + signal[index + 1].im * frac
                        };
                        
                        symbols.push(interpolated);
                        
                        // Gardner timing error detector
                        if (symbols.length >= 3) {
                            const ted = this.gardnerTED(
                                symbols[symbols.length - 3],
                                symbols[symbols.length - 2],
                                symbols[symbols.length - 1]
                            );
                            
                            // Update timing
                            this.timingRecovery.error = ted;
                            this.timingRecovery.mu += this.timingRecovery.gain * ted;
                            
                            // Wrap mu
                            if (this.timingRecovery.mu > 1) this.timingRecovery.mu -= 1;
                            if (this.timingRecovery.mu < 0) this.timingRecovery.mu += 1;
                        }
                    }
                    
                    i += this.samplesPerSymbol;
                }
                
                return symbols;
            }
            
            gardnerTED(early, prompt, late) {
                const real = (late.re - early.re) * prompt.re;
                const imag = (late.im - early.im) * prompt.im;
                return real + imag;
            }
            
            carrierRecoveryProcess(symbols) {
                return symbols.map(symbol => {
                    // Rotate by current phase estimate
                    const rotation = { re: Math.cos(-this.carrierRecovery.phase), im: Math.sin(-this.carrierRecovery.phase) };
                    const corrected = this.complexMultiply(symbol, rotation);
                    
                    // Phase detector (for QAM, use decision-directed)
                    const decision = this.makeDecision(corrected);
                    const error = Math.atan2(
                        corrected.im * decision.re - corrected.re * decision.im,
                        corrected.re * decision.re + corrected.im * decision.im
                    );
                    
                    // Loop filter (2nd order)
                    const alpha = 2 * this.carrierRecovery.damping * this.carrierRecovery.loopBW;
                    const beta = this.carrierRecovery.loopBW * this.carrierRecovery.loopBW;
                    
                    this.carrierRecovery.frequency += beta * error;
                    this.carrierRecovery.phase += alpha * error + this.carrierRecovery.frequency;
                    
                    // Wrap phase
                    this.carrierRecovery.phase = ((this.carrierRecovery.phase + Math.PI) % (2 * Math.PI)) - Math.PI;
                    
                    return corrected;
                });
            }
            
            equalizerProcess(symbols) {
                const output = [];
                
                for (const symbol of symbols) {
                    // Shift buffer
                    this.equalizer.buffer.pop();
                    this.equalizer.buffer.unshift(symbol);
                    
                    // Apply equalizer
                    let equalized = { re: 0, im: 0 };
                    for (let i = 0; i < this.equalizer.taps.length; i++) {
                        const prod = this.complexMultiply(this.equalizer.buffer[i], this.equalizer.taps[i]);
                        equalized = this.complexAdd(equalized, prod);
                    }
                    
                    output.push(equalized);
                    
                    // LMS adaptation
                    const decision = this.makeDecision(equalized);
                    const error = this.complexSubtract(decision, equalized);
                    
                    // Update taps
                    for (let i = 0; i < this.equalizer.taps.length; i++) {
                        const update = this.complexMultiply(
                            { re: error.re * this.equalizer.mu, im: error.im * this.equalizer.mu },
                            this.complexConjugate(this.equalizer.buffer[i])
                        );
                        this.equalizer.taps[i] = this.complexAdd(this.equalizer.taps[i], update);
                    }
                }
                
                return output;
            }
            
            makeDecision(symbol) {
                // Find nearest constellation point
                let minDist = Infinity;
                let decision = { re: 0, im: 0 };
                
                const k = Math.sqrt(this.modOrder);
                const scale = Math.sqrt(2 / (this.modOrder - 1));
                
                for (let i = 0; i < k; i++) {
                    for (let q = 0; q < k; q++) {
                        const point = {
                            re: scale * (2 * i - k + 1),
                            im: scale * (2 * q - k + 1)
                        };
                        
                        const dist = Math.pow(symbol.re - point.re, 2) + Math.pow(symbol.im - point.im, 2);
                        if (dist < minDist) {
                            minDist = dist;
                            decision = point;
                        }
                    }
                }
                
                return decision;
            }
            
            // Complex math utilities
            complexMultiply(a, b) {
                return {
                    re: a.re * b.re - a.im * b.im,
                    im: a.re * b.im + a.im * b.re
                };
            }
            
            complexAdd(a, b) {
                return { re: a.re + b.re, im: a.im + b.im };
            }
            
            complexSubtract(a, b) {
                return { re: a.re - b.re, im: a.im - b.im };
            }
            
            complexConjugate(a) {
                return { re: a.re, im: -a.im };
            }
            
            filterComplex(signal, filter) {
                const output = new Array(signal.length).fill({ re: 0, im: 0 });
                
                for (let n = 0; n < signal.length; n++) {
                    let sum = { re: 0, im: 0 };
                    
                    for (let k = 0; k < filter.length; k++) {
                        if (n - k >= 0) {
                            sum.re += signal[n - k].re * filter[k];
                            sum.im += signal[n - k].im * filter[k];
                        }
                    }
                    
                    output[n] = sum;
                }
                
                return output;
            }
            
            gaussianRandom() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }
            
            // Calculate metrics
            calculateMetrics(txSymbols, rxSymbols) {
                let errors = 0;
                let evmSum = 0;
                let signalPower = 0;
                let noisePower = 0;
                
                const minLen = Math.min(txSymbols.length, rxSymbols.length);
                
                for (let i = 0; i < minLen; i++) {
                    // BER calculation
                    const txDecision = this.makeDecision(txSymbols[i]);
                    const rxDecision = this.makeDecision(rxSymbols[i]);
                    
                    if (txDecision.re !== rxDecision.re || txDecision.im !== rxDecision.im) {
                        errors++;
                    }
                    
                    // EVM calculation
                    const errorVector = this.complexSubtract(rxSymbols[i], txSymbols[i]);
                    const errorPower = errorVector.re * errorVector.re + errorVector.im * errorVector.im;
                    evmSum += errorPower;
                    
                    signalPower += txSymbols[i].re * txSymbols[i].re + txSymbols[i].im * txSymbols[i].im;
                    noisePower += errorPower;
                }
                
                this.metrics.ber = errors / minLen;
                this.metrics.evm = 100 * Math.sqrt(evmSum / signalPower);
                this.metrics.snr = 10 * Math.log10(signalPower / noisePower);
                this.metrics.mer = -20 * Math.log10(Math.sqrt(evmSum / signalPower));
            }
            
            // Visualization
            initializeCanvases() {
                this.canvases = {
                    txConstellation: document.getElementById('txConstellation'),
                    rxConstellation: document.getElementById('rxConstellation'),
                    pulseShape: document.getElementById('pulseShapeCanvas'),
                    baseband: document.getElementById('basebandCanvas'),
                    txSpectrum: document.getElementById('txSpectrumCanvas'),
                    rxSpectrum: document.getElementById('rxSpectrumCanvas'),
                    channelImpulse: document.getElementById('channelImpulseCanvas'),
                    channelTransfer: document.getElementById('channelTransferCanvas'),
                    matchedFilter: document.getElementById('matchedFilterCanvas'),
                    timingRecovery: document.getElementById('timingRecoveryCanvas'),
                    eyeDiagram: document.getElementById('eyeDiagram'),
                    berCurve: document.getElementById('berCurve'),
                    constellationDensity: document.getElementById('constellationDensity'),
                    loopConvergence: document.getElementById('loopConvergence')
                };
                
                // Set canvas sizes
                Object.values(this.canvases).forEach(canvas => {
                    if (canvas) {
                        canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                        canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                        const ctx = canvas.getContext('2d');
                        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                    }
                });
            }
            
            drawConstellation(canvasId, symbols, isIdeal = false) {
                const canvas = this.canvases[canvasId];
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                
                // Draw axes
                ctx.beginPath();
                ctx.moveTo(width/2, 0);
                ctx.lineTo(width/2, height);
                ctx.moveTo(0, height/2);
                ctx.lineTo(width, height/2);
                ctx.stroke();
                
                // Draw circles
                ctx.strokeStyle = '#111';
                for (let r = 0.5; r <= 2; r += 0.5) {
                    ctx.beginPath();
                    ctx.arc(width/2, height/2, r * width/4, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // Plot symbols
                const scale = width / 6;
                
                if (isIdeal) {
                    // Draw ideal constellation points
                    ctx.fillStyle = '#0f0';
                    const k = Math.sqrt(this.modOrder);
                    const norm = Math.sqrt(2 / (this.modOrder - 1));
                    
                    for (let i = 0; i < k; i++) {
                        for (let q = 0; q < k; q++) {
                            const x = width/2 + norm * (2 * i - k + 1) * scale;
                            const y = height/2 - norm * (2 * q - k + 1) * scale;
                            
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                } else {
                    // Draw received symbols with density
                    symbols.forEach(symbol => {
                        const x = width/2 + symbol.re * scale;
                        const y = height/2 - symbol.im * scale;
                        
                        ctx.fillStyle = 'rgba(0, 136, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
                
                // Labels
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText('I', width - 15, height/2 - 5);
                ctx.fillText('Q', width/2 + 5, 12);
            }
            
            drawPulseShape() {
                const canvas = this.canvases.pulseShape;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Draw impulse response
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const samples = this.pulseShapeFilter.length;
                for (let i = 0; i < samples; i++) {
                    const x = i * width / samples;
                    const y = height/2 - this.pulseShapeFilter[i] * height/3;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw frequency response
                const fftSize = 1024;
                const fftReal = new Float32Array(fftSize);
                const fftImag = new Float32Array(fftSize);
                
                // Zero-pad filter
                for (let i = 0; i < this.pulseShapeFilter.length && i < fftSize; i++) {
                    fftReal[i] = this.pulseShapeFilter[i];
                }
                
                // Simple DFT (would use FFT in production)
                ctx.strokeStyle = '#08f';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let k = 0; k < fftSize/2; k++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < fftSize; n++) {
                        const angle = -2 * Math.PI * k * n / fftSize;
                        real += fftReal[n] * Math.cos(angle);
                        imag += fftReal[n] * Math.sin(angle);
                    }
                    
                    const mag = Math.sqrt(real*real + imag*imag);
                    const magDb = 20 * Math.log10(mag + 1e-10);
                    
                    const x = k * width / (fftSize/2);
                    const y = height - (magDb + 60) * height / 80;
                    
                    if (k === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            drawSpectrum(canvasId, signal) {
                const canvas = this.canvases[canvasId];
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Simple periodogram
                const fftSize = 1024;
                const spectrum = new Float32Array(fftSize);
                
                for (let k = 0; k < fftSize; k++) {
                    let real = 0, imag = 0;
                    
                    for (let n = 0; n < Math.min(signal.length, fftSize); n++) {
                        const angle = -2 * Math.PI * k * n / fftSize;
                        real += signal[n].re * Math.cos(angle) - signal[n].im * Math.sin(angle);
                        imag += signal[n].re * Math.sin(angle) + signal[n].im * Math.cos(angle);
                    }
                    
                    spectrum[k] = real*real + imag*imag;
                }
                
                // Convert to dB and plot
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let i = 0; i < fftSize; i++) {
                    const freq = (i - fftSize/2) * this.sampleRate / fftSize;
                    const powerDb = 10 * Math.log10(spectrum[(i + fftSize/2) % fftSize] + 1e-10);
                    
                    const x = i * width / fftSize;
                    const y = height - (powerDb + 100) * height / 120;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw frequency scale
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText('-10 MHz', 5, height - 5);
                ctx.fillText('0', width/2 - 5, height - 5);
                ctx.fillText('+10 MHz', width - 45, height - 5);
            }
            
            drawEyeDiagram(symbols) {
                const canvas = this.canvases.eyeDiagram;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                // Persistence effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, width, height);
                
                // Draw eye traces
                const tracesPerSymbol = 2;
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                
                for (let trace = 0; trace < Math.min(symbols.length - tracesPerSymbol, 100); trace++) {
                    ctx.beginPath();
                    
                    for (let i = 0; i < tracesPerSymbol * this.samplesPerSymbol; i++) {
                        const symbolIdx = trace + Math.floor(i / this.samplesPerSymbol);
                        if (symbolIdx >= symbols.length) break;
                        
                        const x = (i % (tracesPerSymbol * this.samplesPerSymbol)) * width / (tracesPerSymbol * this.samplesPerSymbol);
                        const y = height/2 - symbols[symbolIdx].re * height/4;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    ctx.stroke();
                }
                
                // Draw decision thresholds
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.setLineDash([5, 5]);
                
                const k = Math.sqrt(this.modOrder);
                const norm = Math.sqrt(2 / (this.modOrder - 1));
                
                for (let i = 0; i < k - 1; i++) {
                    const level = norm * (2 * i - k + 2);
                    const y = height/2 - level * height/4;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
